import es.upm.babel.cclib.Monitor;
import es.upm.babel.cclib.Monitor.Cond;


public class ControlAccesoNavesMonitor implements ControlAccesoNaves {
	private Monitor [] mutex;
	private Cond [] condicionEntrar;
	private Cond [] condicionSalir;
	private int[] controlPeso;
	private int[] controlPasillo;
	public ControlAccesoNavesMonitor(){		
		mutex= new Monitor[Robots.N_NAVES];
		condicionEntrar = new Cond [Robots.N_NAVES] ;
		condicionSalir = new Cond [Robots.N_NAVES] ;
		
		//Lets get started wohoooooooo
		for ( int i = 0; i< Robots.N_NAVES; i++){
			mutex[i]= new Monitor();
			condicionEntrar[i] = mutex[i].newCond();
			condicionSalir[i] = mutex[i].newCond();
		}
		
		controlPeso=new int[Robots.N_NAVES];
		controlPasillo=new int[Robots.N_NAVES];
	}
	public void solicitarEntrar(int n, int p) {
		mutex[n].enter();
		while(controlPeso[n]+p>Robots.MAX_PESO_EN_NAVE)
			condicionEntrar[n].await();	
		
		controlPeso[n]=controlPeso[n]+p;
		
		controlPasillo[n]=0;
		if (condicionSalir[n].waiting() != 0)
			condicionSalir[n].signal();
		
		mutex[n].leave();
	}
	public void solicitarSalir(int n, int p) {
		mutex[n].enter();
		while(!(n==Robots.N_NAVES-1 || controlPasillo[n] == 0))
			condicionSalir[n].await();
		
		if(n!=Robots.N_NAVES-1){
			controlPeso[n]=controlPeso[n]-p;
			controlPasillo[n+1]=p;
		}
		//Desbloquear otros
		if (condicionEntrar[n].waiting() >0)
		condicionEntrar[n].signal();
		
		mutex[n].leave();
	}
	
}
